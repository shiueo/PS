---
title: "BOJ - 1788"
description: "피보나치 수의 확장"
date: "2023-05-03"
tags: ['BOJ', 'Rust']
---
## Problem
수학에서, 피보나치 수는 위의 점화식과 같이 귀납적으로 정의되는 수열이다. 위의 식에서도 알 수 있듯이, 피보나치 수 F(n)은 0 이상의 n에 대해서만 정의된다. 하지만 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. 위의 식에서 n > 1인 경우에만 성립하는 F(n) = F(n-1) + F(n-2)를 n ≤ 1일 때도 성립되도록 정의하는 것이다. 예를 들어 n = 1일 때 F(1) = F(0) + F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다. n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하시오. n은 음수로 주어질 수도 있다.

## Input
첫째 줄에 n이 주어진다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.

## Output
첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다. 둘째 줄에는 F(n)의 절댓값을 출력한다. 이 수가 충분히 커질 수 있으므로, 절댓값을 1,000,000,000으로 나눈 나머지를 출력한다.

---
```rust
use std::io;

fn main() {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();

    let mut n:i32 = input.trim().parse().unwrap();

    let mut fibonacci:Vec<i32> = vec![0,1];
    if n > 0 {
        for i in 1..n as usize {
            fibonacci.push((fibonacci[i] + fibonacci[i-1])% 1000000000);
        }
        n = fibonacci[fibonacci.len()-1];
    }
        else if n == 0 {
            fibonacci.pop();
        }
    else {
        n = n.abs();
        for i in 1..n as usize {
            fibonacci.push((fibonacci[i] + fibonacci[i-1])% 1000000000);
        }
        if n % 2 == 0 {
            n = -1*fibonacci[fibonacci.len()-1];
        }
        else {
            n = fibonacci[fibonacci.len()-1];
        }
    }

    if n > 0 {
        println!("1");
    }
    else if n == 0 {
        println!("0");
    }
    else {
        println!("-1");
    }
    println!("{}", n.abs());
}
```
---

전형적 Dynamic Programming이다. 1차원 배열로 피보나치 수열을 구하였고, n < 0의 경우에는 n이 짝수일 경우에만 음수가 되기에 나중에 판별을 해주었다.

Python을 메인으로 사용하던 사람이라 처음에 Rust usize에서 overflow가 발생해 어떻게 해야 하나 하고 있었는데, 1,000,000,000으로 나누라고 하였으므로 이 나머지들만 저장을 하여 해결하였다.

Python의 자료구조가 차지하는 메모리 크기를 신경쓰지 않아도 된다는 점이 정말 편한 것 같다.

## Result
| Mem      | Time | Language  | Length |
|----------|------|-----------|--------|
| 17252 KB | 8 ms | Rust 2018 | 925 B  |
